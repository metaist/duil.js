<!doctype html>
<html><head>
  <meta charset="utf-8" />
  <title>Image Rows Example</title>
  <style>
    .hidden { display: none; }

    .row {
      margin: 0;
      padding: 0.25rem;
      display: flex;
      flex-direction: row;
      border-bottom: 1px solid #ccc;
    }

    .no-email { border: 1px solid black; }
    .gravatar {
      width: 50px;
      min-height: 50px;
      padding: 0;
      margin: 0;
    }

    .images { margin-left: 1rem; }
    .images img { padding-left: 0.5rem; }
  </style>
</head>
<body>
  <div class="container">
    <div class="row">
      <div class="gravatar">
        <img class="gravicon" src="" />
      </div>

      <div class="images">
        <img src="" />
      </div>
    </div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.10/lodash.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/mazondo/gravatarjs/gravatar.js"></script>
<script src="../dist/duil.min.js"></script>
<script>
  /* global $:true, duil:true, gravatar:true */
  class ImageList extends duil.List {
    constructor(props) {
      super(Object.assign({selector: 'img'}, props));
    }

    /**
      @description
      Now we define how the data provided to us in the model should update
      the DOM.

      @override
      @param {jQuery} $img The DOM node to update.
      @param {Object} image The data model.
      @param {number} index The model index.
      @returns {jQuery} The rendered DOM.
      */
    // eslint-disable-next-line class-methods-use-this
    update($img, image, index) {
      // Update the image src and title attributes. We are assuming these are
      // always present.
      $img.set({
        'attr:src': image.path,
        'attr:title': image.timestamp
      });

      // Return the rendered DOM.
      return $img;
    }
  }

  /**
    @description
    The list of users is the top-level list of users. Each row has an
    optional gravatar and list of images (managed by imageList).
  */
  var userList = new duil.List({

    /**
      @description
      Now we define the behavior of the outer widget.

      @override
      @property {jQuery} $dom The container into which rows will be rendered.
      */
    $dom: $('.container'),

    /**
      @description
      And we specify the selector for the outside widget.

      @override
      @property {string} selector The query selector for the rows.
      */
    selector: '.row',

    // We keep track of the ImageList objects we create here.
    images: {},

    /**
      @description
      This is where we create a user. We create the HTML using the normal
      `duil.List.create` method and then we create a corresponding ImageList.

      @override
      @param {*} user The data for this element.
      @param {Number} index The model index.
      @returns {jQuery} Returns the new element.
    */
    create: function (user, index) {
      const view = this.invoke(duil.List, 'create', user, index);
      this.images[user.id] = new ImageList({
        $dom: view.find('.images'),
        data: user.images
      });
      return view;
    },

    /**
      @description
      Here we define the rules for updating a single row. First, we update the
      gravicon. If there's no email address, then hide the image.

      Next, we set the imageList widget data to be the images and we set it's
      container to be the div inside this template. This will cause the
      imageList widget to re-render in the context of this div.

      Finally, we return the properly rendered view.

      @override
      @param {jQuery} $row The row to update.
      @param {Object} user The user data model.
      @param {number} index The index of the model.
      */
    update: function ($row, user, index) {
      // We walk through our template and set properties as appropriate.
      $row
        .data('id', user.id)
        .find('.gravatar') // Find the outside div for the gravatar icon.
          .set({ // Add a border if there's no email and we set the tooltip.
            'toggleClass:no-email': !user.email,
            'attr:title': user.email ? user.email : 'No email address'
          })
        .end() // Bump our context back up to the whole row.
        .find('.gravicon') // Find the image itself.
          .set({ // Hide the image if there's no email and update the image src.
            'toggleClass:hidden': !user.email,
            'attr:src': user.email ? gravatar(user.email) : ''
          })
        .end();

      // Now render the images for this user. Because the `.create()` method
      // also calls `.update()`, we need to check if the ImageList has been
      // created yet.
      if (this.images[user.id]) {
        this.images[user.id].set({data: user.images});
      }

      // Return the rendered row.
      return $row;
    },


    /**
      @description
      Whenever we need to remove a user row, we need to also clean up the
      corresponding `ImageList`.

      @override
      @param {jQuery} views The DOM objects to remove.
      @returns {duil.List} The widget itself for chaining.
      */
    remove: function(views) {
      views.forEach((view) => { this.images[$(view).data('id')] = null; });
      return this.invoke(duil.List, 'remove', views);
    }
  });

  // We define some users.
  const users = [{
    // A user with no email address and no images.
    id: 1,
    email: '',
    images: []
  }, {
    // A user with an email address, but no images.
    id: 2,
    email: 'example@example.com',
    images: []
  }, {
    // A user with an image, but no email address.
    id: 3,
    email: '',
    images: [{
      path: 'http://via.placeholder.com/50x50',
      timestamp: '2018-05-13T00:00:00.000Z'
    }]
  }];

  // Now we set the userList data to the users we created.
  userList.set({data: users});

  // Add some more data to the model.
  userList.set({data: userList.data.concat([{
    // A user with an email address and images.
    id: 4,
    email: 'metaist+duil@metaist.com',
    images: [{
      path: 'http://via.placeholder.com/50x50',
      timestamp: '2018-05-14T00:00:00.000Z'
    }, {
      path: 'http://via.placeholder.com/100x50',
      timestamp: '2018-05-15T00:00:00.000Z'
    }]
  }])});

  // Update a specific item.
  userList.set({
    'data[2].email': 'tom@mojombo.com' // Creator of Gravatars.
  });
</script>
</body></html>
