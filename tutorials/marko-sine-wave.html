<!doctype html>
<html><head>
<title>marko sine wave in duil</title>
<style>
/* From: https://github.com/marko-js/markojs-website/blob/master/routes/index/components/sine-wave/index.marko */
.animated-sin-wave {
    position: relative;
    height: 150px;
    width: 100%;
    overflow: hidden;
}

.animated-sin-wave > .bar {
    position: absolute;
    height: 100%;
    border-radius: 50%;
    max-width:10px;
}

.animated-sin-wave-description {
    width:100%;
    text-align:center;
    font-size:0.8em;
    color:#747678;
    padding: 2em
}
</style>
</head><body>
  <div>
    <a href="https://github.com/metaist/duil.js/blob/master/tutorials/marko-sine-wave.html">view code</a>
    (<a href="https://github.com/marko-js/markojs-website/blob/master/routes/index/components/sine-wave/index.marko">original</a>)
    <hr />
  </div>

  <div class="animated-sin-wave" id="sine-wave-animation">
    <div class="bar"></div>
  </div>

  <p class="animated-sin-wave-description">
    The above animation is <span class="barCount"></span>
    <code>&lt;div></code> tags.
    No SVG, no CSS transitions/animations.
    It's all powered by <strike>Marko</strike> duil which does a full re-render
    every frame.
  </p>

<script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/duil/dist/duil.min.js"></script>
<script>
//From: https://github.com/marko-js/markojs-website/blob/master/util/isElementInViewport.js
function elementInRange(x, a, b) {
  return x >= a && x <= b;
}

function isElementInViewport(element, options) {
  const scrollY = window.scrollY;
  const scrollBottom = scrollY + window.innerHeight;
  const elOffsetTop = element.offsetTop;
  const elBottomPos = elOffsetTop + element.offsetHeight;
  return (
    elementInRange(elOffsetTop, scrollY, scrollBottom) ||
    elementInRange(elBottomPos, scrollY, scrollBottom)
  );
}
// end: isElementInViewport.js

// Based on: https://github.com/marko-js/markojs-website/blob/master/routes/index/components/sine-wave/index.marko
let barCount;
let barWidth;

new duil.List({
  $dom: $('.animated-sin-wave'),
  selector: '.bar',
  data: [],

  state: {
    active: false,
    count: 0,
  },

  step: 0.5,

  // @override
  update: function (view, model, i) {
    const count = this.state.count;

    const translateY = Math.sin(count/10 + i/5) * 100 * .5;
    const hue = (360/barCount * i - count) % 360;
    const color = 'hsl('+hue+',95%,55%)';
    const rotation = (count+i)%360;
    const barX = barWidth * i;

    $(view).css({
      width: `${barWidth}%`,
      left: `${barX}%`,
      transform:
        `scale(0.8,.5) translateY(${translateY}%) rotate(${rotation}deg)`,
      backgroundColor: color
    });

    return view;
  },

  // duil-related: move handlers
  init: function () {
    this.$dom.on('click', this.switchDirection);
    this.invoke(duil.List, 'init'); // extract the template
    this.onMount(); // call marko's onMount
    return this;
  },
  onMount: function () {
    this.nextFrame = this.nextFrame.bind(this);
    $(window).resize(() => this.scale());
    this.registerAnimationViewListener();
    this.scale();

    if (this.shouldShowAnimation()) {
      this.start();
    }
  },
  scale: function () {
    barCount = Math.min(200, Math.floor(window.innerWidth / 15));
    barWidth = 100 / barCount;

    // duil-related: update the text of the div and resize the data array
    $('.barCount').text(barCount);
    this.set({data: Array(barCount).fill(0)});
  },
  start: function () {
    if (!this.state.active) {
      this.state.active = true;
      this.nextFrame();
    }
  },
  stop: function() {
    this.state.active = false;
  },
  switchDirection: function() {
    this.step *= -1;
  },
  nextFrame: function() {
    if (this.state.active) {
      // duil needs to see a change in data, but we can just call update
      this.data.forEach((_, i) => this.update(this.views[i], null, i));

      this.state.count += this.step;
      window.requestAnimationFrame(this.nextFrame);
    }
  },
  registerAnimationViewListener: function() {
    $(window).scroll(() => {
      const inView = this.shouldShowAnimation();
      if (!inView) {
        this.stop();
      } else if (inView && this.state.active === false) {
        this.start();
      }
    });
  },
  shouldShowAnimation: function() {
    const el = this.$dom[0];
    return isElementInViewport(el);
  }
});
</script>
</body></html>
