<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>FabricJS Example</title>
  <body>
    <canvas id="canvas" style="border: 1px solid black;"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/1.7.22/fabric.min.js"></script>
    <script src="../dist/duil.js"></script>
    <script>
      /* global fabric: true, duil: true */

      /**
        @description
        Construct a widget to draw squares on a canvas. For this example, we'll
        create a duil.Group which maps data models (Object[]) to
        views (fabric.Rect[]).
      */
      const squares = new duil.Group({

        /**
          By convention, we list the properties we want to define first.
          Here I create a new canvas object (fabric.Canvas).

          I could name this whatever I want. Later, I'll be able to access this
          property using `this.canvas`.

          @property {fabric.Canvas} canvas
        */
        canvas: new fabric.Canvas('canvas'),

        /**
          @description
          Here we override the default duil.Group.create function. This function
          gets called during render whenever there is a new model, but no
          associated view.

          Given the model, our job is to create the view and make it visibile
          to the user. Because our rendering logic is similar to .update(),
          we create our view (a `fabric.Rect`) and then immediately update it.

          We also have to add it to the list of views that this
          group is going to track.

          Finally, we return the view.

          @override
          @param {Object} model The data for which to create a fabric.Rect.
          @param {number} index The model index.
          @returns {fabric.Rect} Returns the fabric.Rect we created.
         */
        create: function (model, index) {
          // create a new view (fabric.Rect)
          const view = new fabric.Rect({fill: 'blue', height: 10, width: 10});

          // call the update function (duil.Group.update)
          this.update(view, model, index);

          // add the view to the canvas (fabric.Canvas)
          this.canvas.add(view);

          // add the view to the list of views (duil.Group.views)
          this.views.splice(index, 0, view);
          return view;
        },

        /**
          @description
          We also override the default duil.Group.update function. This function
          also gets called during render when there is an existing view for a
          model (and above where we call it when creating a view).

          For this simple example, it simply converts the "x" and "y" properties
          of the model to "top" and "left" properties of the fabric.Rect.

          Like with the create function above, we return the view when we're
          done.

          @override
          @param {fabric.Rect} view The view to update.
          @param {Object} model The data to use for the update.
          @param {number} index The model index.
          @returns {fabric.Rect} Returns the fabric.Rect we updated.
         */
        update: function (view, model, index) {
          view.set({top: model.y, left: model.x});
          return view;
        },

        /**
          @description
          This function is called at the end of render to remove all the views
          that no longer have models backing them.

          First, we remove the fabric.Rect objects from the canvas.

          Then, we call the duil.Group.remove function which removes the views
          from the array of views.

          Finally, we return the widget itself.

          @override
          @param {fabric.Rect[]} views The views to remove.
          @returns {duil.Group} Returns the widget itself.
          */
        remove: function (views) {
          views.forEach(view => this.canvas.remove(view));
          this.invoke(duil.Group, 'remove', views);
          return this;
        },

        /**
          @description
          This is the function that gets called when the data is changed.
          For this example, we simply call the normal duil.Group.render which
          will create, update, and remove fabric.Rect objects.

          The only special thing we need to do here is tell the fabric.Canvas
          to re-render.

          Finally, we return the widget itself.

          @override
          @returns {duil.Group} Returns the widget itself.
          */
        render: function () {
          this.invoke(duil.Group, 'render');
          this.canvas.renderAll();
          return this;
        }
      });

      // Now that the widget behavior is defined, we set the data to an array
      // of point which will get drawn as squares.
      squares.set({
        data: [
          {x: 10, y: 10},
          {x: 20, y: 20}
        ]
      });

      // We can change the data of an multiple points:
      squares.set({
        'data[0].x': 30,
        'data[1].y': 40
      });

      // We can add more points:
      squares.set({
        data: squares.data.concat([
          {x: 50, y: 50},
          {x: 60, y: 60}
        ])
      });

      // We can remove a point (by defining which points should stay):
      squares.set({
        data: squares.data.slice(1, 3) // only keep the middle two points
      });
    </script>
  </body>
</html>
